#  数据在内存中的存储



> 类型的意义：
>
> 1.使用这个类型开辟内存空间的大小（大小决定了适用范围）
>
> 2.如何看待内存空间的额视角

## 1.整形在内存中的存储





## 2.浮点型在内存中的存储

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);
	printf("pFloat的值为：%f\n", *pFloat);

	*pFloat = 9.0;
	printf("num的值为：%d\n", n);
	printf("pFloat的值为：%f\n", *pFloat);
    return 0;

}
```

![](https://lqr-1317479009.cos.ap-shanghai.myqcloud.com/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8.PNG)

n和*pFloat在内存中明明是同一个数，浮点数和整数解读结果差别很大。要理解这一结果，一定要搞懂浮点数在计算机内部的表示方法。



根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式： 

> - (-1)^S * M * 2^E
> - (-1)^S表示符号位，当S=0，v为正数；当S=1，v为负数
> - M表示有效数字，大于等于1，小于2
> - 2^E表示指数位



举例来说，

十进制的5.0，写成二进制是101.0，相当于(-1)^0 * 1.01 * 2^2。那么，按照上面v的格式，可以得出S=0，M=1.01，E=2。

十进制的-5.0，写成二进制是-101.0，相当于(-1)^1 * 1.01 * 2^2。那么，按照上面v的格式，可以得出S=1，M=1.01，E=2。



**IEEE 754规定**：

对于32位·的浮点数，最高1位是符号位S，接着的8位是指数位E，剩下的23位是有效数字位M。

![](https://lqr-1317479009.cos.ap-shanghai.myqcloud.com/32%E4%BD%8D%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8.PNG)

对于64位·的浮点数，最高1位是符号位S，接着的11位是指数位E，剩下的52位是有效数字位M。

![](https://lqr-1317479009.cos.ap-shanghai.myqcloud.com/64%E4%BD%8D%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8.PNG)

**IEEE 754对有效数字M和指数E，还有一些特别规定。**

**==对于有效数字M，省略第一位的1再保存在内存中==**

前面说过，1<=M<2，也就是说，M可以写成1.xxxxx的形式，其中xxxxx表示小数部分。

IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保留后面的xxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的是，节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去后，等于可以保存24位有效数字。

**==至于指数E，E的真实值加上中间数再保存在内存中==**

首先，E为一个无符号整数（unsigned int）这意味着，如果E为8位，它的取值范围为0~255；如果如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。



然后，指数E从内存中取出还可以分成三种情况：

**E不全为0或不全为1**

> 这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数M前加上第一位的1。比如：0.5的二进制形式为0.1。由于规定有效数字部分必须大于等于1，即将小数点右移1位，则为1.0*2^(-1)，其阶码为-1+127=126，表示为011111110，而尾数部分1.0去掉整数部分为0，补齐到23位00000000000000000000000，则该二进制表示形式为
>
> 0 01111110 00000000000000000000000（这四个字节保存在内存中依旧要考虑大小端字节序）



**E全为0**

> 这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxx的小数。这样特殊处理是为了表示接近于0的很小的数字。如果有效数字M全为0，等效于+0/-0（正负取决于符号位S）。



**E全为1**

> 这时，浮点数的指数E正常操作，即指数E的计算值减去127（或1023），得到真实值为**128**，再将有效数M前加上第一位的1。如果有效数字M全为0，等效于+无穷大/-无穷大正负取决于符号位S）。



**END**
